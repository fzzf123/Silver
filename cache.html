<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>cache.rb</title>
  <link rel="stylesheet" href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div id="jump_to">
    Jump To &hellip;
    <div id="jump_wrapper">
      <div id="jump_page">
        <a class="source" href="cache.html">cache.rb</a>
        <a class="source" href="common_words.html">common_words.rb</a>
        <a class="source" href="indexer.html">indexer.rb</a>
        <a class="source" href="search.html">search.rb</a>
        </div>
    </div>
  </div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>cache.rb</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-1'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-1">#</a>
        </div>
        <h3>Hash extensions</h3>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-2'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-2">#</a>
        </div>
        <p> Creates a new class, BareHash, that is alike a Hash in every way except that
 it may be accessed by a symbol or a string for every key. Really the same thing
 as HashWithIndifferentAccess but without ActiveSupport</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">class</span> <span class="nc">BareHash</span> <span class="o">&lt;</span> <span class="no">Hash</span>

    <span class="k">def</span> <span class="nf">[]</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">include?</span> <span class="n">key</span>
            <span class="nb">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="n">key</span><span class="o">.</span><span class="n">class</span> <span class="o">==</span> <span class="nb">String</span> <span class="p">?</span> <span class="nb">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">to_sym</span><span class="p">,</span><span class="kp">nil</span><span class="p">)</span> <span class="p">:</span> <span class="nb">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span>
        <span class="k">end</span>

    <span class="k">end</span>

<span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-3'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-3">#</a>
        </div>
        <p> Monkey patches Hash to allow for conversion to a BareHash where all values are strings. This
 is good for mixing results with Redis results which are always stored as strings.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">class</span> <span class="nc">Hash</span>

    <span class="k">def</span> <span class="nf">to_bare</span>

        <span class="n">bhash</span> <span class="o">=</span> <span class="no">BareHash</span><span class="o">.</span><span class="n">new</span>
        <span class="nb">self</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="o">|</span> <span class="n">bhash</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">}</span>
        <span class="n">bhash</span>

    <span class="k">end</span>

<span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-4'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-4">#</a>
        </div>
        <h3>Caching</h3>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">module</span> <span class="nn">Silver</span>

  <span class="k">class</span> <span class="nc">Cache</span>
    
    <span class="kp">attr_reader</span> <span class="ss">:key</span><span class="p">,</span> <span class="ss">:time_field</span><span class="p">,</span> <span class="ss">:query</span></pre></div>
      </td>
    </tr>
    <tr id='section-5'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-5">#</a>
        </div>
        <p> Creates a new cached search object.</p>

<p> Silver does not connect to a database, the query is passed as a block. This means you can use
 Silver to cache databases, REST APIs, or anything else that can be queried.</p>

<p> key is string to identify this and successive queries to Redis
 time_field is the name of a field used to determine whether or not there are new entries that
 are not yet cached.
 query is a block that take a date and queries the database for all entries after that date. The results
 must be returned in descending order.</p>

<p> Example to prepare a cache and query for the database of new stories in blog #2:</p>

<pre><code> cache = Silver::Cache.new("news_stories",
                           "created_time") do |date|

   Stories.all(:order =&gt; :created_time.desc,
               :created_time.gt =&gt; date
               :blog_id =&gt; 2)

 end 
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">time_field</span><span class="p">,</span><span class="n">redis_options</span><span class="o">=</span><span class="p">{},</span><span class="o">&amp;</span><span class="n">query</span><span class="p">)</span>
    
        <span class="vi">@key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="vi">@time_field</span> <span class="o">=</span> <span class="n">time_field</span>
        <span class="vi">@query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="vi">@r</span> <span class="o">=</span> <span class="no">Redis</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">redis_options</span><span class="p">)</span>
        <span class="vi">@r</span><span class="o">.</span><span class="n">select</span> <span class="mi">12</span>
    
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-6'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-6">#</a>
        </div>
        <p> Queries Redis, returns new entries and inserts them into Redis.</p>

<p> callback is block that gets called for every new results, receives the result
 and returns a hash of additional attributes. This is used to query associations.</p>

<p> Example to cache and the query the database and include any categories the entry might have:</p>

<pre><code> cache.find{|entry| {:categories =&gt; entry.categories}}
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>      
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
      
      <span class="n">old_results</span> <span class="o">=</span> <span class="vi">@r</span><span class="o">.</span><span class="n">lrange</span><span class="p">(</span><span class="vi">@key</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">q</span><span class="o">|</span> <span class="no">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">q</span><span class="p">)}</span>
      <span class="n">last_date</span> <span class="o">=</span> <span class="vi">@r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@key</span><span class="si">}</span><span class="s2">:last&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="s2">&quot;1970-01-01&quot;</span>
      <span class="n">new_results</span> <span class="o">=</span> <span class="vi">@query</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="no">DateTime</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">last_date</span><span class="p">))</span>
      
      <span class="n">results</span> <span class="o">=</span> <span class="n">new_results</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span> 
        <span class="k">if</span> <span class="nb">block_given?</span>
            <span class="n">add_on</span> <span class="o">=</span> <span class="n">callback</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">merge</span> <span class="n">add_on</span>
        <span class="k">else</span>
          <span class="n">result</span><span class="o">.</span><span class="n">attributes</span>
        <span class="k">end</span>
      <span class="k">end</span> 
      
      <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">empty?</span>
          <span class="n">final_results</span> <span class="o">=</span> <span class="n">old_results</span>
      <span class="k">else</span> 
          <span class="n">write_new</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
          </pre></div>
      </td>
    </tr>
    <tr id='section-7'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-7">#</a>
        </div>
        <p> Why do we go back to Redis here instead of just merging old and new? Because it&rsquo;s faster and cleaner than
 selectively determining which types are changed by the to_json (like Dates) and which are preservered (like
 Hashes).</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>          <span class="n">final_results</span> <span class="o">=</span> <span class="vi">@r</span><span class="o">.</span><span class="n">lrange</span><span class="p">(</span><span class="vi">@key</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">q</span><span class="o">|</span> <span class="no">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">q</span><span class="p">)}</span>
      <span class="k">end</span>
      
      <span class="n">final_results</span> <span class="o">=</span> <span class="n">final_results</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span> 
          <span class="n">result</span><span class="o">.</span><span class="n">to_bare</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-8'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-8">#</a>
        </div>
        <p> A helper method to keep the redis list at a reasonable size.</p>

<p> length is the number of entries to reduce the redis to</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">cull</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>

        <span class="vi">@r</span><span class="o">.</span><span class="n">ltrim</span><span class="p">(</span><span class="vi">@key</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">end</span>
    
    <span class="kp">private</span></pre></div>
      </td>
    </tr>
    <tr id='section-9'>
      <td class=docs>
        <div class="octowrap">
          <a class="octothorpe" href="#section-9">#</a>
        </div>
        <p> Writes the results to redis by pushing them in reverse order on the head
 of the redis list. This ensures that the first result will always be the newest.
 Also turns every result hash into JSON before writing because Redis is string based.
 Find will automatically parse these JSON strings upon retrieval.</p>

      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">write_new</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
          
          <span class="n">new_date</span> <span class="o">=</span> <span class="n">results</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="vi">@time_field</span><span class="o">].</span><span class="n">to_s</span>
          <span class="vi">@r</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@key</span><span class="si">}</span><span class="s2">:last&quot;</span><span class="p">,</span><span class="n">new_date</span><span class="p">)</span>
          
          <span class="n">results</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="o">|</span>
            <span class="vi">@r</span><span class="o">.</span><span class="n">lpush</span><span class="p">(</span><span class="vi">@key</span><span class="p">,</span><span class="n">result</span><span class="o">.</span><span class="n">to_json</span><span class="p">)</span>
          <span class="k">end</span>

    <span class="k">end</span>

  <span class="k">end</span>

<span class="k">end</span></pre></div>
      </td>
    </tr>
    </table>
</div>
</body>
